# -*- coding: utf-8 -*-
"""Predicting Marathon Participation_ Analyzing Trends and Building a Forecasting Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kRSAOZWukU-mcIopNxZAGGGvkfBrRiCV
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
from sklearn.model_selection import train_test_split,GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score, precision_score, recall_score, f1_score
from sklearn.preprocessing import Binarizer
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

data=pd.read_excel("/content/Races.xlsx")
data.head()

data.dtypes

data.info()

data.shape

print(data.describe())

data['Date'] = pd.to_datetime(data['Date'], errors='coerce')
print(data['Date'])

missing_dates = data['Date'].isnull().sum()
print(missing_dates)

data = data.dropna(subset=['Date'])
 print(data)

data['Month'] = data['Date'].dt.month
data['Day'] = data['Date'].dt.day
data['Weekday'] = data['Date'].dt.weekday
print(data['Month'])

duplicates = data.duplicated().sum()
print(duplicates)

data = data.drop_duplicates()

missing_values = data.isnull().sum()
print(missing_values)

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
data['Finishers'] = scaler.fit_transform(data[['Finishers']])
print(data['Finishers'])

plt.figure(figsize=(12, 10))
numerical_data = data.select_dtypes(include=np.number)
sns.heatmap(numerical_data.corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Numerical Features')
plt.show()

selected_features = ['Finishers', 'Month', 'Day', 'Weekday']
G=sns.pairplot(data[selected_features],palette='RDBu_r')
plt.show()

G.map(plt.scatter)
G.add_legend()

def _plot_series(series, series_name, series_index=0):
  palette = list(sns.palettes.mpl_palette('Dark2'))
  xs = series['Date']
  ys = series['Finishers']

  plt.plot(xs, ys, label=series_name, color=palette[series_index % len(palette)])

fig, ax = plt.subplots(figsize=(10, 5.2), layout='constrained')
df_sorted = data.sort_values('Date', ascending=True)
for i, (series_name, series) in enumerate(df_sorted.groupby('Season')):
  _plot_series(series, series_name, i)
  fig.legend(title='Season', bbox_to_anchor=(1, 1), loc='upper left')
sns.despine(fig=fig, ax=ax)
plt.xlabel('Date')
_ = plt.ylabel('Finishers')

figsize = (12, 1.2 * len(data['Season'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(data, x='Weekday', y='Season', inner='box', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

categorical_features = ['Finishers']
for feature in categorical_features:
  if feature in data.columns:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x=feature, y='Month', data=data,palette='coolwarm')
    plt.title(f'Boxplot of Finishers by {feature}')
    plt.show()

top_marathons = data.groupby('Race')['Finishers'].sum().sort_values(ascending=False).head(5).reset_index()

plt.figure(figsize=(8, 8))
plt.pie(top_marathons['Finishers'], labels=top_marathons['Race'], autopct='%1.1f%%', colors=sns.color_palette('pastel'))
plt.show()

sns.histplot(data['Finishers'],kde=False,bins=50)
plt.axvline(0,color="k",linestyle="--")

import plotly.express as px
fig = px.violin(data_frame=data,
                y='Finishers',
                box=True,
                points="all",
                title="Distribution of Finishers",
                color_discrete_sequence=['lightpink'])
fig.show()

sns.lmplot(x='Year', y='Finishers', data=data,markers=".",scatter_kws=dict(color='c'))
plt.show()

fig = px.box(data, y="Finishers", points="all", title="Boxplot of Finishers")
fig.show()

def categorize_race_size(finishers):
    if finishers < 20000:
        return 'Short'
    elif 20000 <= finishers < 40000:
        return 'Medium'
    else:
        return 'Long'

data['Race_Size_Category'] = data['Finishers'].apply(categorize_race_size)
print(data['Race_Size_Category'])

seasons = {1: 'Winter', 2: 'Winter', 3: 'Spring', 4: 'Spring', 5: 'Spring',
           6: 'Summer', 7: 'Summer', 8: 'Summer', 9: 'Fall', 10: 'Fall', 11: 'Fall', 12: 'Winter'}
data['Season'] = data['Month'].map(seasons)
print(data['Season'])

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
data['Race_Encoded'] = le.fit_transform(data['Race'])
data['Season_Encoded'] = le.fit_transform(data['Season'])
data['Race_Size_Category_Encoded'] = le.fit_transform(data['Race_Size_Category'])
print(data['Race_Encoded'])

data['Season_Encoded']

data['Race_Size_Category_Encoded']

features = ['Year', 'Month', 'Weekday', 'Race_Encoded', 'Season_Encoded', 'Race_Size_Category_Encoded']
target = 'Finishers'

X = data[features]
y = data[target]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mse

r2

threshold = y_test.median()
binarizer = Binarizer(threshold=threshold)
y_test_binary = binarizer.fit_transform(y_test.values.reshape(-1, 1)).flatten()
y_pred_binary = binarizer.transform(y_pred.reshape(-1, 1)).flatten()

accuracy = accuracy_score(y_test_binary, y_pred_binary)
precision = precision_score(y_test_binary, y_pred_binary)
recall = recall_score(y_test_binary, y_pred_binary)
f1 = f1_score(y_test_binary, y_pred_binary)

accuracy

precision

import xgboost as xgb
from sklearn.model_selection import GridSearchCV

xgb_model = xgb.XGBRegressor(random_state=42)
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [3, 6, 10],
    'learning_rate': [0.01, 0.1, 0.3],
    'subsample': [0.7, 0.8, 1.0],
    'colsample_bytree': [0.7, 0.8, 1.0]
}
grid_search = GridSearchCV(estimator=xgb_model, param_grid=param_grid, cv=3, n_jobs=-1, verbose=2)

xgb_model = xgb.XGBRegressor(random_state=42)
xgb_model.fit(X_train, y_train)

y_pred = xgb_model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
rmse = mse ** 0.5
r2 = r2_score(y_test, y_pred)

print("RMSE:", rmse)
print("R^2 Score:", r2)

residuals = y_test - y_pred

plt.figure(figsize=(10, 6))
plt.scatter(y_pred, residuals, alpha=0.6)
plt.axhline(0, color='red', linestyle='--', linewidth=1)
plt.title('Residuals vs Predicted Values')
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
plt.grid(True)
plt.show()